#!/usr/bin/env ruby
# frozen_string_literal: true

# bin/walk — CLI entrypoint for walk explorations.
#
# Human-facing:
#   walk new <name> [--title '...']
#   walk run <name> [--once] [--dry-run] [--preview <slug>]
#   walk status <name>
#
# Agent-facing (use WALK_DIR/WALK_ISSUE env vars, or --walk-dir/--slug flags):
#   walk show <slug> [--walk-dir PATH]
#   walk close [--status STATUS] --reason 'reason' [--walk-dir PATH] [--slug SLUG]
#   walk comment 'text' [--walk-dir PATH] [--slug SLUG]
#   walk create <slug> --title '...' [--type TYPE] [--priority N] [--blocked-by SLUG] --body '...' [--walk-dir PATH]
#   walk list [--status open|closed] [--walk-dir PATH]
#   walk runs <slug> [--walk-dir PATH]
#
# All subcommands support --json for structured output.

$stdout.sync = true
$stderr.sync = true

require "yaml"
require "json"
require "fileutils"
require "time"
require "optparse"

require_relative "../lib/walk/directory_backend"
require_relative "../lib/walk/prompt_builder"
require_relative "../lib/walk/reporting"
require_relative "../lib/walk/driver"

# ---------------------------------------------------------------------------
# CLI subcommands
# ---------------------------------------------------------------------------

def resolve_walk_dir(name_or_env)
  # If WALK_DIR env is set, use it
  if name_or_env.nil? && ENV["WALK_DIR"]
    return ENV["WALK_DIR"]
  end

  return nil if name_or_env.nil?

  # If it's an absolute or relative path that exists, use it
  expanded = File.expand_path(name_or_env)
  return expanded if Dir.exist?(expanded)

  # Try as a subdirectory name
  nil
end

def resolve_slug(args, env_key: "WALK_ISSUE")
  slug = args.shift
  slug ||= ENV[env_key]
  slug
end

def output(data, json: false)
  if json
    puts JSON.pretty_generate(data)
  else
    yield data if block_given?
  end
end

# --- Subcommand: new ---

def cmd_new(args)
  title = nil
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk new <name> [--title '...']"
    opts.on("--title TITLE", "Walk title") { |t| title = t }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  unless name
    $stderr.puts parser.help
    exit 1
  end

  title ||= name
  path = File.expand_path(name)

  backend = Walk::DirectoryBackend.new(path)
  result = backend.scaffold_walk(title: title)
  unless result
    exit 1
  end

  output(result, json: json_output) do |r|
    puts "Created walk: #{r[:title]}"
    puts "  Directory: #{r[:walk_dir]}"
    puts "  Add issues in: #{r[:walk_dir]}/open/"
  end
end

# --- Subcommand: run ---

def cmd_run(args)
  once = false
  dry_run = false
  preview = nil
  preview_planning = false
  claude_md = nil
  command = nil
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk run <name> [--once] [--dry-run] [--preview <slug>] [--preview-planning]"
    opts.on("--once", "Run one issue then exit") { once = true }
    opts.on("--dry-run", "Print prompts without spawning agents") { dry_run = true }
    opts.on("--preview SLUG", "Preview prompt for a specific issue") { |s| preview = s }
    opts.on("--preview-planning", "Preview the planning prompt") { preview_planning = true }
    opts.on("--claude-md PATH", "Path to CLAUDE.md (default: WALK_DIR/CLAUDE.md if present)") { |p| claude_md = p }
    opts.on("--command CMD", "Agent command (default: claude)") { |c| command = c }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    $stderr.puts parser.help
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)

  # Read walk-level config from _walk.md frontmatter (if present)
  walk_meta = backend.read_walk_meta
  walk_config = walk_meta ? walk_meta[:config] : {}

  # Re-entrancy check: warn if walk was previously completed/stalled/stopped
  if walk_meta && %w[completed stalled stopped].include?(walk_meta[:status])
    $stderr.puts "Warning: walk '#{walk_meta[:title]}' has status '#{walk_meta[:status]}'"
    if walk_meta[:frontmatter]["finish_reason"]
      $stderr.puts "  Reason: #{walk_meta[:frontmatter]["finish_reason"]}"
    end
    $stderr.puts "  Resetting status to 'open' to continue."
    backend.update_walk_status("open")
  end

  # Merge: CLI flags > walk config > hardcoded defaults
  effective_claude_md = claude_md ||
    walk_config[:claude_md_path] ||
    (File.exist?(File.join(walk_dir, "CLAUDE.md")) ? File.join(walk_dir, "CLAUDE.md") : nil)
  effective_close_protocol = walk_config.fetch(:close_protocol, :result_md)
  effective_spawn_mode = walk_config.fetch(:spawn_mode, :capture)
  effective_max_turns = walk_config.fetch(:max_turns, 10)
  effective_sleep_interval = walk_config.fetch(:sleep_interval, 5)
  effective_model = walk_config[:model]
  effective_preamble = walk_config[:preamble]
  effective_max_concurrent = walk_config.fetch(:max_concurrent, 1)

  prompt_builder = Walk::PromptBuilder.new(
    project_dir: walk_dir,
    claude_md_path: effective_claude_md,
    preamble: effective_preamble,
    close_protocol: effective_close_protocol
  )

  # Default logs_dir to walk_dir/logs/ for stream mode output capture
  effective_logs_dir = walk_config[:logs_dir] || File.join(walk_dir, "logs")

  driver = Walk::Driver.new(
    backend: backend,
    prompt_builder: prompt_builder,
    logs_dir: effective_logs_dir,
    spawn_mode: effective_spawn_mode,
    max_turns: effective_max_turns,
    sleep_interval: effective_sleep_interval,
    model: effective_model,
    max_concurrent: effective_max_concurrent,
    command: command
  )

  if preview
    driver.preview(preview)
  elsif preview_planning
    driver.preview_planning
  else
    driver.run(once: once, dry_run: dry_run)
  end
end

# --- Subcommand: status ---

def cmd_status(args)
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk status <name>"
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  status = backend.walk_status

  output(status, json: json_output) do |s|
    Walk::Reporting.print_status(s)
  end
end

# --- Subcommand: show ---

def cmd_show(args)
  json_output = false
  walk_dir_flag = nil
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk show <slug> [--walk-dir PATH]"
    opts.on("--walk-dir PATH", "Walk directory (overrides WALK_DIR env)") { |p| walk_dir_flag = p }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  slug = resolve_slug(args)
  walk_dir = walk_dir_flag || resolve_walk_dir(nil)
  unless slug && walk_dir
    $stderr.puts "Error: slug required (pass as argument or set WALK_ISSUE env)"
    $stderr.puts "Error: WALK_DIR env or --walk-dir must be set" unless walk_dir
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  issue = backend.show_issue(slug)
  unless issue
    $stderr.puts "Error: issue '#{slug}' not found"
    exit 1
  end

  output(issue, json: json_output) do |i|
    puts "#{i[:slug]} — #{i[:title]}"
    puts "Type: #{i[:type]} | Priority: #{i[:priority]} | Status: #{i[:status]}"
    puts ""
    puts i[:body] if i[:body] && !i[:body].empty?
    if i[:close_reason]
      puts ""
      puts "Close reason: #{i[:close_reason]}"
    end
    if i[:result]
      puts ""
      puts "Result:"
      puts i[:result]
    end
  end
end

# --- Subcommand: close ---

def cmd_close(args)
  reason = nil
  close_status = "closed"
  json_output = false
  walk_dir_flag = nil
  slug_flag = nil
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk close [--status STATUS] --reason 'reason' [--walk-dir PATH] [--slug SLUG]"
    opts.on("--reason REASON", "Close reason (required)") { |r| reason = r }
    opts.on("--status STATUS", "Status: closed, blocked, deferred (default: closed)") { |s| close_status = s }
    opts.on("--walk-dir PATH", "Walk directory (overrides WALK_DIR env)") { |p| walk_dir_flag = p }
    opts.on("--slug SLUG", "Issue slug (overrides WALK_ISSUE env)") { |s| slug_flag = s }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  # Allow reason as positional arg if --reason not given
  reason ||= args.shift

  slug = slug_flag || ENV["WALK_ISSUE"]
  walk_dir = walk_dir_flag || resolve_walk_dir(nil)

  unless reason
    $stderr.puts "Error: --reason is required"
    $stderr.puts parser.help
    exit 1
  end
  unless slug
    $stderr.puts "Error: WALK_ISSUE env var or --slug must be set"
    exit 1
  end
  unless walk_dir
    $stderr.puts "Error: WALK_DIR env var or --walk-dir must be set"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  result = backend.close_issue(slug, reason: reason, status: close_status)
  unless result
    exit 1
  end

  output(result, json: json_output) do |r|
    puts "Closed #{r[:slug]} (#{r[:status]}): #{r[:reason]}"
  end
end

# --- Subcommand: comment ---

def cmd_comment(args)
  json_output = false
  walk_dir_flag = nil
  slug_flag = nil
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk comment 'text' [--walk-dir PATH] [--slug SLUG]"
    opts.on("--walk-dir PATH", "Walk directory (overrides WALK_DIR env)") { |p| walk_dir_flag = p }
    opts.on("--slug SLUG", "Issue slug (overrides WALK_ISSUE env)") { |s| slug_flag = s }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  text = args.join(" ")
  slug = slug_flag || ENV["WALK_ISSUE"]
  walk_dir = walk_dir_flag || resolve_walk_dir(nil)

  if text.empty?
    $stderr.puts "Error: comment text required"
    exit 1
  end
  unless slug
    $stderr.puts "Error: WALK_ISSUE env var or --slug must be set"
    exit 1
  end
  unless walk_dir
    $stderr.puts "Error: WALK_DIR env var or --walk-dir must be set"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  result = backend.add_comment(slug, text)
  unless result
    exit 1
  end

  output(result, json: json_output) do |r|
    puts "Comment added to #{r[:slug]}"
  end
end

# --- Subcommand: create ---

def cmd_create(args)
  title = nil
  type = "task"
  priority = 2
  body = ""
  blocked_by = []
  json_output = false
  walk_dir_flag = nil
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk create <slug> --title '...' [--type TYPE] [--priority N] [--blocked-by SLUG] --body '...' [--walk-dir PATH]"
    opts.on("--title TITLE", "Issue title (required)") { |t| title = t }
    opts.on("--type TYPE", "Issue type (default: task)") { |t| type = t }
    opts.on("--priority N", Integer, "Priority 1-3 (default: 2)") { |p| priority = p }
    opts.on("--blocked-by SLUG", "Blocking issue slug (repeatable)") { |s| blocked_by << s }
    opts.on("--body TEXT", "Issue body/description") { |b| body = b }
    opts.on("--walk-dir PATH", "Walk directory (overrides WALK_DIR env)") { |p| walk_dir_flag = p }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  slug = args.shift
  walk_dir = walk_dir_flag || resolve_walk_dir(nil)

  unless slug
    $stderr.puts "Error: slug required"
    $stderr.puts parser.help
    exit 1
  end
  unless title
    $stderr.puts "Error: --title required"
    $stderr.puts parser.help
    exit 1
  end
  unless walk_dir
    $stderr.puts "Error: WALK_DIR env var or --walk-dir must be set"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  result = backend.create_issue_by_slug(slug,
    title: title, type: type, priority: priority,
    body: body, blocked_by: blocked_by.empty? ? nil : blocked_by)
  unless result
    exit 1
  end

  output(result, json: json_output) do |r|
    puts "Created issue: #{r[:slug]} — #{r[:title]}"
    puts "  Type: #{r[:type]} | Priority: #{r[:priority]}"
    puts "  Dir: #{r[:dir]}"
  end
end

# --- Subcommand: runs ---

def cmd_runs(args)
  json_output = false
  walk_dir_flag = nil
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk runs <slug> [--walk-dir PATH]"
    opts.on("--walk-dir PATH", "Walk directory (overrides WALK_DIR env)") { |p| walk_dir_flag = p }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  slug = resolve_slug(args)
  walk_dir = walk_dir_flag || resolve_walk_dir(nil)

  unless slug
    $stderr.puts "Error: slug required (pass as argument or set WALK_ISSUE env)"
    exit 1
  end
  unless walk_dir
    $stderr.puts "Error: WALK_DIR env var or --walk-dir must be set"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  issue = backend.show_issue(slug)
  unless issue
    $stderr.puts "Error: issue '#{slug}' not found"
    exit 1
  end

  runs_dir = File.join(issue[:dir], "runs")
  unless Dir.exist?(runs_dir)
    output([], json: json_output) { puts "No runs for #{slug}." }
    return
  end

  runs = Dir.children(runs_dir).sort.filter_map { |ts_dir|
    full = File.join(runs_dir, ts_dir)
    next unless Dir.exist?(full)

    meta_file = File.join(full, "meta.json")
    meta = File.exist?(meta_file) ? JSON.parse(File.read(meta_file), symbolize_names: true) : {}
    {
      timestamp: ts_dir,
      dir: full,
      exit_code: meta[:exit_code],
      started_at: meta[:started_at],
      finished_at: meta[:finished_at],
      cost_usd: meta[:cost_usd],
      has_prompt: File.exist?(File.join(full, "prompt.txt")),
      has_output: File.exist?(File.join(full, "output.txt")),
      has_stderr: File.exist?(File.join(full, "stderr.txt"))
    }
  }

  output(runs, json: json_output) do |list|
    if list.empty?
      puts "No runs for #{slug}."
    else
      puts "Runs for #{slug} (#{list.length}):"
      list.each do |r|
        status = r[:exit_code] ? "exit=#{r[:exit_code]}" : "no meta"
        cost = r[:cost_usd] ? " $#{"%.2f" % r[:cost_usd]}" : ""
        files = []
        files << "prompt" if r[:has_prompt]
        files << "output" if r[:has_output]
        files << "stderr" if r[:has_stderr]
        puts "  #{r[:timestamp]}  #{status}#{cost}  [#{files.join(", ")}]"
      end
    end
  end
end

# --- Subcommand: history ---

def cmd_history(args)
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk history <name>"
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  data = Walk::Reporting.walk_data(backend)

  json_data = {
    title: data[:title],
    body: data[:body],
    started_at: data[:started_at]&.iso8601,
    issues_closed: data[:issues_closed],
    timeline: data[:timeline],
    total_runs: data[:total_runs],
    total_duration_s: data[:total_duration_s],
    total_cost: data[:total_cost]
  }

  output(json_data, json: json_output) do |_|
    Walk::Reporting.print_history(data)
  end
end

# --- Subcommand: summary ---

def cmd_summary(args)
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk summary <name>"
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  data = Walk::Reporting.walk_data(backend)

  json_data = {
    title: data[:title],
    body: data[:body],
    started_at: data[:started_at]&.iso8601,
    issues_closed: data[:issues_closed],
    open_issues_count: data[:open_issues_count],
    timeline: data[:timeline],
    open_issues: data[:open_issues].map { |i| { slug: i[:slug], title: i[:title], type: i[:type], priority: i[:priority] } },
    total_runs: data[:total_runs],
    total_duration_s: data[:total_duration_s],
    total_cost: data[:total_cost]
  }

  output(json_data, json: json_output) do |_|
    puts Walk::Reporting.render_summary_markdown(data)
  end
end

# --- Subcommand: list ---

def cmd_list(args)
  list_status = "open"
  json_output = false
  walk_dir_flag = nil
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk list [--status open|closed] [--walk-dir PATH]"
    opts.on("--status STATUS", "Filter by status: open or closed (default: open)") { |s| list_status = s }
    opts.on("--walk-dir PATH", "Walk directory (overrides WALK_DIR env)") { |p| walk_dir_flag = p }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  walk_dir = walk_dir_flag || resolve_walk_dir(args.shift)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: WALK_DIR env var, --walk-dir, or walk name must be provided"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  issues = backend.list_issues(status: list_status)

  output(issues, json: json_output) do |list|
    if list.empty?
      puts "No #{list_status} issues."
    else
      list.each do |i|
        prefix = list_status == "closed" ? "x" : " "
        puts "[#{prefix}] #{i[:slug]} — #{i[:title]} (P#{i[:priority]}, #{i[:type]})"
      end
    end
  end
end

# --- Subcommand: tree ---

def cmd_tree(args)
  mode = :discovery
  json_output = false
  root_slug = nil
  include_closed = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk tree <name> [--mode discovery|blocking] [--root SLUG] [--all]"
    opts.on("--mode MODE", "Tree type: discovery (default) or blocking") { |m| mode = m.to_sym }
    opts.on("--root SLUG", "Start tree from specific issue") { |r| root_slug = r }
    opts.on("--all", "Include closed issues (default: open only)") { include_closed = true }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)

  case mode
  when :discovery
    tree = backend.build_discovery_tree(include_closed: include_closed)
    if json_output
      puts JSON.pretty_generate(tree.slice(:roots, :children, :parent_of).merge(
        issues: tree[:issues].transform_values { |i| { slug: i[:slug], title: i[:title], status: i[:status] } }
      ))
    else
      lines = backend.render_discovery_tree(tree, root: root_slug)
      puts lines.join("\n")
    end
  when :blocking
    tree = backend.build_blocking_tree(include_closed: include_closed)
    if json_output
      puts JSON.pretty_generate(tree.slice(:roots, :blocked_by).merge(
        issues: tree[:issues].transform_values { |i| { slug: i[:slug], title: i[:title], status: i[:status] } }
      ))
    else
      lines = backend.render_blocking_tree(tree)
      puts lines.join("\n")
    end
  else
    $stderr.puts "Unknown mode: #{mode}. Use 'discovery' or 'blocking'."
    exit 1
  end
end

# ---------------------------------------------------------------------------
# Main dispatch
# ---------------------------------------------------------------------------

# --- Subcommand: resume ---

def cmd_resume(args)
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk resume <name>"
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)
  meta = backend.read_walk_meta

  unless meta && %w[completed stalled stopped].include?(meta[:status])
    $stderr.puts "Walk is not closed (status: #{meta&.dig(:status) || 'unknown'})"
    exit 1
  end

  result = backend.update_walk_status("open")

  output(result, json: json_output) do |r|
    puts "Resumed walk (was: #{meta[:status]})"
    if meta[:frontmatter]["finish_reason"]
      puts "  Previous reason: #{meta[:frontmatter]["finish_reason"]}"
    end
  end
end

# --- Subcommand: follow ---

def cmd_follow(args)
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk follow <name> [log-file]"
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  logs_dir = File.join(walk_dir, "logs")
  unless Dir.exist?(logs_dir)
    $stderr.puts "Error: logs directory not found: #{logs_dir}"
    exit 1
  end

  # Find latest output.jsonl or use specified file
  log_file = args.shift
  unless log_file
    candidates = Dir.glob(File.join(logs_dir, "*-output.jsonl")).sort_by { |f| File.mtime(f) }
    if candidates.empty?
      $stderr.puts "No output logs found in #{logs_dir}"
      exit 1
    end
    log_file = candidates.last
  end
  log_file = File.join(logs_dir, log_file) unless log_file.start_with?("/")

  puts "Following: #{log_file}"
  puts "=" * 60

  # Track file position for tail -f behavior
  last_size = 0

  loop do
    current_size = File.size(log_file) rescue 0

    if current_size > last_size
      File.open(log_file, "r") do |f|
        f.seek(last_size)
        f.each_line do |line|
          print_jsonl_line(line.strip)
        end
      end
      last_size = current_size
    end

    sleep 0.3
  end
rescue Interrupt
  puts "\nStopped."
end

def print_jsonl_line(line)
  return if line.empty?

  begin
    data = JSON.parse(line)
  rescue JSON::ParserError
    puts line
    return
  end

  type = data["type"]
  case type
  when "assistant"
    msg = data.dig("message", "content")
    return unless msg.is_a?(Array)

    msg.each do |block|
      case block["type"]
      when "text"
        puts "\n\e[36m#{block["text"]}\e[0m"
      when "thinking"
        puts "\n\e[33m[thinking] #{block["thinking"]}\e[0m"
      when "tool_use"
        name = block["name"]
        input = block["input"]
        puts "\n\e[32m→ #{name}\e[0m"
        if input.is_a?(Hash)
          input.each do |k, v|
            v_str = v.is_a?(String) ? v : v.to_json
            v_str = v_str[0..200] + "..." if v_str.length > 200
            puts "    #{k}: #{v_str}"
          end
        end
      end
    end

  when "user"
    # Tool results
    msg = data.dig("message", "content")
    return unless msg.is_a?(Array)

    msg.each do |block|
      next unless block["type"] == "tool_result"
      content = block["content"]
      content = content[0..500] + "..." if content.is_a?(String) && content.length > 500
      puts "\e[90m← #{content}\e[0m"
    end

  when "system"
    subtype = data["subtype"]
    case subtype
    when "init"
      puts "\e[35m[session init] model=#{data["model"]}\e[0m"
    end
  end
end

# --- Subcommand: epochs ---

def cmd_epochs(args)
  init_mode = false
  json_output = false
  parser = OptionParser.new do |opts|
    opts.banner = "Usage: walk epochs <name> [--init]"
    opts.on("--init", "Backfill epochs from closed_at timestamps") { init_mode = true }
    opts.on("--json", "Output as JSON") { json_output = true }
  end
  parser.parse!(args)

  name = args.shift
  walk_dir = resolve_walk_dir(name)
  unless walk_dir && Dir.exist?(walk_dir)
    $stderr.puts "Error: walk directory not found: #{name}"
    exit 1
  end

  backend = Walk::DirectoryBackend.new(walk_dir)

  if init_mode
    # Backfill epochs from closed_at timestamps (group by day)
    closed = backend.list_issues(status: "closed")
    if closed.empty?
      puts "No closed issues to backfill."
      return
    end

    # Group by date (closed_at day)
    by_date = closed.group_by { |i|
      # Parse closed_at, fall back to "unknown"
      if i[:closed_at]
        Time.parse(i[:closed_at].to_s).strftime("%Y-%m-%d") rescue "unknown"
      else
        "unknown"
      end
    }

    # Sort dates and assign epochs
    sorted_dates = by_date.keys.sort
    puts "Backfilling #{closed.size} issues across #{sorted_dates.size} dates..."

    epochs_dir = File.join(walk_dir, "epochs")
    FileUtils.mkdir_p(epochs_dir)

    sorted_dates.each_with_index do |date, idx|
      epoch = idx + 1
      epoch_dir = File.join(epochs_dir, epoch.to_s)
      FileUtils.mkdir_p(epoch_dir)

      issues = by_date[date]
      issues.each do |issue|
        slug = issue[:slug]
        symlink_path = File.join(epoch_dir, slug)
        target = "../../closed/#{slug}"
        FileUtils.rm_f(symlink_path)
        File.symlink(target, symlink_path)
      end

      puts "  Epoch #{epoch} (#{date}): #{issues.size} issues"
    end

    # Update current epoch
    File.write(File.join(epochs_dir, "current"), sorted_dates.size.to_s)
    puts "Done. Current epoch: #{sorted_dates.size}"
  else
    # Show epoch info
    current = backend.current_epoch
    all_epochs = backend.list_epochs

    if json_output
      data = {
        current_epoch: current,
        epochs: all_epochs.map { |e| { epoch: e, count: backend.issues_in_epoch(e).size } }
      }
      puts JSON.pretty_generate(data)
    else
      if all_epochs.empty?
        puts "No epochs yet. Run 'walk epochs --init' to backfill from existing issues."
      else
        puts "Current epoch: #{current}"
        puts "All epochs:"
        all_epochs.each do |e|
          issues = backend.issues_in_epoch(e)
          puts "  #{e}: #{issues.size} issues"
        end
      end
    end
  end
end

SUBCOMMANDS = {
  "new"     => method(:cmd_new),
  "run"     => method(:cmd_run),
  "status"  => method(:cmd_status),
  "history" => method(:cmd_history),
  "summary" => method(:cmd_summary),
  "tree"    => method(:cmd_tree),
  "show"    => method(:cmd_show),
  "close"   => method(:cmd_close),
  "comment" => method(:cmd_comment),
  "create"  => method(:cmd_create),
  "list"    => method(:cmd_list),
  "runs"    => method(:cmd_runs),
  "resume"  => method(:cmd_resume),
  "follow"  => method(:cmd_follow),
  "epochs"  => method(:cmd_epochs)
}.freeze

def main
  if ARGV.empty? || ARGV.first == "--help" || ARGV.first == "-h"
    puts <<~HELP
      walk — CLI for walk explorations

      Human-facing:
        walk new <name> [--title '...']                Create a new walk
        walk run <name> [--once] [--dry-run]           Run the driver loop
              [--preview <slug>]                       Preview issue prompt
              [--preview-planning]                     Preview planning prompt
              [--claude-md PATH]                       Path to CLAUDE.md
              [--command CMD]                          Agent command (default: claude)
        walk status <name>                             Show walk dashboard
        walk history <name>                            Chronological timeline
        walk summary <name>                            Markdown summary report
        walk tree <name> [--mode MODE] [--root SLUG]   Show issue hierarchy
              MODE: discovery (parent->children) or blocking (execution order)

      Agent-facing (WALK_DIR/WALK_ISSUE env vars, or --walk-dir/--slug flags):
        walk show <slug>                      Show issue details
        walk close --reason 'reason'          Close current issue
        walk comment 'text'                   Add comment to current issue
        walk create <slug> --title '...'      Create new issue
        walk list [--status open|closed]      List issues
        walk runs <slug>                      List runs for an issue

      All subcommands support --json for structured output.
    HELP
    exit 0
  end

  subcmd = ARGV.shift
  handler = SUBCOMMANDS[subcmd]
  unless handler
    $stderr.puts "Unknown subcommand: #{subcmd}"
    $stderr.puts "Run 'walk --help' for usage."
    exit 1
  end

  handler.call(ARGV)
end

main
