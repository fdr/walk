#!/usr/bin/env bash
# bin/walk-trampoline — Self-healing wrapper for walk run.
#
# Runs walk in a loop with a backstop repair agent:
#   Exit 0        = walk completed normally → trampoline exits
#   Exit 42       = restart requested (self-modification) → syntax check → restart
#   Exit 130/143  = SIGINT/SIGTERM → trampoline exits
#   Other         = crash → spawn repair agent → if fixed, restart; else git rollback
#
# Process group management:
#   Walk runs in its own process group (via setsid). On restart/signal, the
#   entire group is killed — preventing orphaned claude agents from interleaving
#   with new runs.
#
# Mutual exclusion:
#   A PID file (WALK_DIR/.trampoline.pid) prevents multiple trampolines from
#   running for the same walk directory. On startup, any existing trampoline is
#   killed. Orphaned claude agents (ppid=1) referencing the walk directory are
#   also killed. The PID file is cleaned up on all exit paths (normal, signal,
#   crash) via an EXIT trap.
#
# Pristine worktree:
#   Maintains WALK_REPO_DIR-pristine/ at LAST_GOOD_COMMIT for side-by-side
#   comparison during repair. The repair agent can diff modified vs pristine
#   to identify which changes broke walk.
#
# Usage:
#   walk-trampoline <walk-dir> [walk-run-flags...]
#   walk-trampoline ~/walks/debian13-port
#   walk-trampoline ~/walks/debian13-port --once
#
# Environment:
#   WALK_REPO_DIR    Path to walk source (default: script's grandparent dir)
#   WALK_MAX_REPAIRS Max consecutive repair attempts before rollback (default: 3)

set -euo pipefail

# Allow nested claude invocations (walk spawns claude agents)
unset CLAUDECODE 2>/dev/null || true
unset CLAUDE_CODE_ENTRYPOINT 2>/dev/null || true

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
WALK_REPO_DIR="${WALK_REPO_DIR:-$(dirname "$SCRIPT_DIR")}"
WALK_BIN="${WALK_REPO_DIR}/bin/walk"
WALK_MAX_REPAIRS="${WALK_MAX_REPAIRS:-3}"
PRISTINE_DIR="${WALK_REPO_DIR}-pristine"

# --- Argument parsing ---

if [ $# -lt 1 ]; then
  echo "Usage: walk-trampoline <walk-dir> [walk-run-flags...]" >&2
  exit 1
fi

WALK_DIR="$1"
shift
WALK_RUN_FLAGS=("$@")

if [ ! -d "$WALK_DIR" ]; then
  echo "Error: walk directory not found: $WALK_DIR" >&2
  exit 1
fi

# --- State tracking ---

LOGS_DIR="${WALK_DIR}/logs"
mkdir -p "$LOGS_DIR"

LAST_GOOD_FILE="${WALK_DIR}/.last_good_commit"
LOCKFILE="${WALK_DIR}/.trampoline.pid"
CONSECUTIVE_FAILURES=0
RESTART_COUNT=0
STDERR_FILE="${LOGS_DIR}/trampoline-stderr.log"
WALK_PID=""

# Initialize LAST_GOOD_COMMIT from file or current HEAD
if [ -f "$LAST_GOOD_FILE" ]; then
  LAST_GOOD_COMMIT="$(cat "$LAST_GOOD_FILE")"
else
  LAST_GOOD_COMMIT="$(cd "$WALK_REPO_DIR" && git rev-parse HEAD)"
  echo "$LAST_GOOD_COMMIT" > "$LAST_GOOD_FILE"
fi

log() {
  echo "[trampoline $(date '+%H:%M:%S')] $*"
}

# --- Mutual exclusion ---

# Acquire the PID file lock. If another trampoline is running for the same
# walk directory, kill it first. Handles the race where two trampolines
# start within milliseconds by re-checking the PID file after a short sleep.
acquire_lock() {
  if [ -f "$LOCKFILE" ]; then
    local old_pid
    old_pid=$(cat "$LOCKFILE")
    if kill -0 "$old_pid" 2>/dev/null; then
      log "Existing trampoline running (PID $old_pid). Killing it..."
      kill "$old_pid" 2>/dev/null || true
      # Give it time to clean up its process group
      sleep 3
      # Force kill if still alive
      if kill -0 "$old_pid" 2>/dev/null; then
        log "Force-killing stale trampoline (PID $old_pid)..."
        kill -9 "$old_pid" 2>/dev/null || true
        sleep 1
      fi
    else
      log "Stale PID file (PID $old_pid not running). Removing."
    fi
    rm -f "$LOCKFILE"
  fi

  # Write our PID
  echo $$ > "$LOCKFILE"

  # Verify we won the race (in case two trampolines start simultaneously)
  sleep 0.2
  if [ "$(cat "$LOCKFILE" 2>/dev/null)" != "$$" ]; then
    echo "Lost PID file race. Another trampoline took over. Exiting." >&2
    exit 1
  fi

  log "Acquired lock (PID $$, lockfile $LOCKFILE)"
}

# Remove the lockfile. Called on all exit paths via trap.
release_lock() {
  # Only remove if it's still ours (avoid removing a new trampoline's PID file)
  if [ -f "$LOCKFILE" ] && [ "$(cat "$LOCKFILE" 2>/dev/null)" = "$$" ]; then
    rm -f "$LOCKFILE"
  fi
}

# Kill orphaned claude processes from a crashed/killed trampoline.
# Targets only claude processes that are children of init (ppid=1) and
# reference this walk directory — these are definitionally orphans from a
# dead parent. The interactive claude session (if any) has a real parent.
kill_orphaned_agents() {
  local walk_dir_escaped
  walk_dir_escaped=$(printf '%s' "$WALK_DIR" | sed 's/[[\.*^$()+?{|]/\\&/g')
  local orphans
  orphans=$(ps -eo pid,ppid,args | awk -v wd="$walk_dir_escaped" '$2 == 1 && /claude/ && $0 ~ wd && !/awk/ {print $1}')
  if [ -n "$orphans" ]; then
    log "Killing orphaned claude processes referencing $WALK_DIR: $orphans"
    echo "$orphans" | xargs kill -9 2>/dev/null || true
  fi
}

# --- Process group management ---

# Kill the walk process group (walk + all its children: claude agents, SSH, etc.)
kill_walk_group() {
  if [ -n "$WALK_PID" ]; then
    # Kill the entire process group led by WALK_PID.
    # setsid makes WALK_PID the process group leader, so -WALK_PID targets
    # all processes in that group.
    kill -- -"$WALK_PID" 2>/dev/null || true
    # Wait briefly for processes to exit
    local waited=0
    while kill -0 "$WALK_PID" 2>/dev/null && [ "$waited" -lt 10 ]; do
      sleep 1
      waited=$((waited + 1))
    done
    # Force kill if still alive
    if kill -0 "$WALK_PID" 2>/dev/null; then
      log "Force-killing walk process group (SIGKILL)..."
      kill -9 -- -"$WALK_PID" 2>/dev/null || true
      sleep 1
    fi
    wait "$WALK_PID" 2>/dev/null || true
    WALK_PID=""
  fi
}

# --- Signal handling ---

# On signal: kill the walk process group and release the lock.
cleanup() {
  local sig="${1:-EXIT}"
  log "Cleanup triggered (${sig}). Killing walk process group..."
  kill_walk_group
  release_lock
  # Exit with appropriate code
  case "$sig" in
    INT)  exit 130 ;;
    TERM) exit 143 ;;
    *)    exit 0 ;;
  esac
}

trap 'cleanup INT' INT
trap 'cleanup TERM' TERM
trap 'release_lock' EXIT

# --- Pristine worktree management ---

setup_pristine_worktree() {
  if [ ! -d "$PRISTINE_DIR" ]; then
    log "Creating pristine worktree at ${PRISTINE_DIR} (commit ${LAST_GOOD_COMMIT})..."
    (cd "$WALK_REPO_DIR" && git worktree add "$PRISTINE_DIR" "$LAST_GOOD_COMMIT" --detach 2>/dev/null) || {
      log "Warning: could not create pristine worktree (non-fatal)."
      return 0
    }
  else
    log "Updating pristine worktree to ${LAST_GOOD_COMMIT}..."
    (cd "$PRISTINE_DIR" && git checkout "$LAST_GOOD_COMMIT" --force 2>/dev/null) || {
      log "Warning: could not update pristine worktree (non-fatal)."
      return 0
    }
  fi
  log "Pristine worktree ready at ${PRISTINE_DIR}"
}

advance_pristine_worktree() {
  local new_commit="$1"
  if [ -d "$PRISTINE_DIR" ]; then
    (cd "$PRISTINE_DIR" && git checkout "$new_commit" --force 2>/dev/null) || {
      log "Warning: could not advance pristine worktree (non-fatal)."
    }
  fi
}

# --- Syntax check ---

syntax_check() {
  log "Running syntax check on walk source..."
  local failed=0
  while IFS= read -r -d '' rbfile; do
    if ! ruby -c "$rbfile" >/dev/null 2>&1; then
      log "Syntax error in: $rbfile"
      ruby -c "$rbfile" 2>&1 | head -5
      failed=1
    fi
  done < <(find "$WALK_REPO_DIR/lib" "$WALK_REPO_DIR/bin" -name '*.rb' -print0 2>/dev/null)
  return $failed
}

# --- Repair agent (ditch repair with worktree diff) ---

spawn_repair_agent() {
  local exit_code="$1"
  log "Spawning repair agent (attempt $((CONSECUTIVE_FAILURES + 1))/${WALK_MAX_REPAIRS})..."

  local crash_log=""
  local driver_log="${LOGS_DIR}/driver.log"
  if [ -f "$driver_log" ]; then
    crash_log="$(tail -200 "$driver_log")"
  fi

  local stderr_tail=""
  if [ -f "$STDERR_FILE" ]; then
    stderr_tail="$(tail -100 "$STDERR_FILE")"
  fi

  # Compute diff between last-known-good and current state
  local worktree_diff=""
  worktree_diff="$(cd "$WALK_REPO_DIR" && git diff "${LAST_GOOD_COMMIT}..HEAD" 2>/dev/null || echo '(no diff available)')"

  # Build the focused ditch repair prompt using worktree comparison
  local repair_prompt
  repair_prompt="walk crashed after self-modification (exit code: ${exit_code}).

Working version (LAST_GOOD_COMMIT ${LAST_GOOD_COMMIT}): ${PRISTINE_DIR}/
Modified version (broken): ${WALK_REPO_DIR}/

Diff between working version and broken version:
${worktree_diff}

Stderr (last 100 lines):
${stderr_tail}

Driver log (last 200 lines):
${crash_log}

Your job: fix ${WALK_REPO_DIR}/ so that \`ruby -c\` passes on all .rb files
and walk can start. Compare each changed file against its pristine version
in ${PRISTINE_DIR}/ to understand what was modified.

Strategy:
1. Read the diff above to identify which changes are likely causing the crash
2. For each suspicious change, compare the file in ${WALK_REPO_DIR}/ against ${PRISTINE_DIR}/
3. Preserve changes that look correct and intentional
4. Revert changes that look broken (syntax errors, logic bugs, missing requires)
5. If you cannot determine the fix, revert the broken files to their pristine versions:
   cp ${PRISTINE_DIR}/path/to/file ${WALK_REPO_DIR}/path/to/file

After fixing, verify every .rb file:
  for f in ${WALK_REPO_DIR}/lib/walk/*.rb ${WALK_REPO_DIR}/bin/walk; do ruby -c \"\$f\" || exit 1; done"

  # Run repair agent
  if claude --print --dangerously-skip-permissions --max-turns 15 \
    -p "$repair_prompt" \
    > "${LOGS_DIR}/repair-$(date '+%Y%m%d-%H%M%S').log" 2>&1; then
    log "Repair agent completed."
    return 0
  else
    log "Repair agent failed (exit $?)."
    return 1
  fi
}

# --- Git rollback ---

git_rollback() {
  log "Rolling back to last good commit: ${LAST_GOOD_COMMIT}"
  (
    cd "$WALK_REPO_DIR"
    # Preserve failed state on a timestamped branch
    local failed_branch="failed/$(date '+%Y%m%d-%H%M%S')"
    git branch "$failed_branch" HEAD 2>/dev/null || true
    log "Failed state preserved on branch: $failed_branch"

    git checkout "$LAST_GOOD_COMMIT" -- . 2>/dev/null
    git checkout -f 2>/dev/null || true
  )
}

# --- Advance good commit ---

advance_good_commit() {
  local new_commit
  new_commit="$(cd "$WALK_REPO_DIR" && git rev-parse HEAD)"
  echo "$new_commit" > "$LAST_GOOD_FILE"
  LAST_GOOD_COMMIT="$new_commit"
  log "Advanced LAST_GOOD_COMMIT to $new_commit"
  advance_pristine_worktree "$new_commit"
}

# --- Main loop ---

log "Starting trampoline for: $WALK_DIR"
log "Walk source: $WALK_REPO_DIR"
log "Last good commit: $LAST_GOOD_COMMIT"

# Acquire exclusive lock for this walk directory.
# Kills any existing trampoline and orphaned claude agents.
acquire_lock
kill_orphaned_agents

# Set up pristine worktree on startup
setup_pristine_worktree

while true; do
  RESTART_COUNT=$((RESTART_COUNT + 1))
  log "=== Run #${RESTART_COUNT} ==="

  # Clear restart marker if present
  rm -f "${WALK_DIR}/_restart_requested"

  # Run walk in its own process group (setsid).
  # This makes WALK_PID the process group leader so we can kill all
  # descendants (claude agents, SSH sessions, etc.) with kill -- -PID.
  set +e
  setsid "$WALK_BIN" run "$WALK_DIR" "${WALK_RUN_FLAGS[@]}" 2>"$STDERR_FILE" &
  WALK_PID=$!
  wait "$WALK_PID"
  EXIT_CODE=$?
  set -e
  WALK_PID=""

  case $EXIT_CODE in
    0)
      log "Walk completed normally (exit 0)."
      CONSECUTIVE_FAILURES=0
      advance_good_commit
      exit 0
      ;;

    42)
      log "Restart requested (exit 42). Checking syntax..."
      CONSECUTIVE_FAILURES=0
      if syntax_check; then
        log "Syntax OK. Restarting walk..."
        continue
      else
        log "Syntax check failed after self-modification!"
        # Try repair
        if spawn_repair_agent "$EXIT_CODE" && syntax_check; then
          log "Repair fixed syntax. Restarting..."
          continue
        else
          log "Could not fix syntax. Rolling back."
          git_rollback
          continue
        fi
      fi
      ;;

    130|143)
      log "Walk received signal (exit $EXIT_CODE). Exiting."
      exit 0
      ;;

    *)
      log "Walk crashed (exit $EXIT_CODE)."
      CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))

      if [ "$CONSECUTIVE_FAILURES" -ge "$WALK_MAX_REPAIRS" ]; then
        log "Reached ${WALK_MAX_REPAIRS} consecutive failures. Rolling back."
        git_rollback
        CONSECUTIVE_FAILURES=0
        continue
      fi

      # Try repair
      if spawn_repair_agent "$EXIT_CODE" && syntax_check; then
        log "Repair succeeded. Restarting..."
        continue
      else
        CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
        if [ "$CONSECUTIVE_FAILURES" -ge "$WALK_MAX_REPAIRS" ]; then
          log "Repair failed. Reached ${WALK_MAX_REPAIRS} consecutive failures. Rolling back."
          git_rollback
          CONSECUTIVE_FAILURES=0
        else
          log "Repair failed. Will retry on next iteration."
        fi
        continue
      fi
      ;;
  esac
done
